<% data = JSON.parse @simulation.state %>

var simulation = {
  rate: 0,                      // in ms
  clock: {
    time: new Date(<%= @simulation.start_on.strftime("%Y, %-m, %-d")%>).getTime(),
    elapsed_time: 0,           // in minutes
  },
  weather: {},
  soil: {},
  patches: [],
  width: 0,
  height: 0,
  water: undefined,
};

postMessage({start_time: '<%= @simulation.start_on.to_s %>'});

// ====================================================
// Message Handler
// Processes messages from the user interface thread
// These are: 
//  (1) initialization messages, (re)setting up the simulation
//  (2) tick messages, advancing the simulation, and
//  (3) various agricultural operations carryed out by the user, 
//      such as planting
//
onmessage = function(msg) {

  switch(msg.data.type) {
    
    case 'init':
      initialize(simulation);
      break;

    case 'tick': 
      simulation.clock.elapsed_time += 1; // Add one minute to elapsed time
      simulation.clock.time += 60000; // Add one minute to time
      update(simulation);
      postMessage({type: 'time_update', time: simulation.clock.time});
      break;
  }


}

//=====================================================
// Simulation API

function get_elapsed_time() {
  return simulation.clock.elapsed_time;
}

// Weather API
<% for property in Weather::PROPERTIES %>
function get_<%= property %>() {
  return simulation.weather.<%= property %>;
}

function set_<%= property %>(value) {
  simulation.weather.<%= property %> = value;
}
<% end %> 

// Soil API
var index = 0
<% for property in Soil::PROPERTIES %>
function get_<%= property %>() {
  return simulation.soil.<%= property %>[index];
}

function set_<%= property %>(value) {
  simulation.soil.<%= property %>[index] = value;
}
<% end %>


//=====================================================
// Simulation initialization methods

function initialize(simulation) {
  initClock(simulation);
  initWeather(simulation);
  initPatches(simulation);
}

function initClock(simulation) {
  simulation.clock = {
    time: new Date(<%= @simulation.start_on.strftime("%Y, %-m, %-d")%>).getTime(),
    elapsed_time: 0,           // in minutes
  }
  postMessage({type: 'time_update', time: simulation.clock.time});
}

function initWeather(simulation) {
  simulation.weather = {
    rainfall: 0,
    snowfall: 0,
    solar_radiation: 0,
    day_length: 0,
    average_temperature: 14,
    low_temperature: 14,
    high_temperature: 14,
    wind_speed: 0,
    wind_direction: 0,
    relative_humidity: 0.5,
  }
}

function initPatches(simulation) {
  var farm = <%= Farm.find(data["farm"]["id"]).data.html_safe %>,
      north = farm.location.latitude, 
      south = farm.location.latitude, 
      east = farm.location.longitude, 
      west = farm.location.longitude,
      widthInPatches,
      heightInPatches,
      degreesPerMeterLat,
      degreesPerMeterLng,
      halfWidth,
      halfHeight;

  // Find the outer boundaries of the simulations
  farm.field_bounds.forEach( function(bounds) {
    bounds.forEach( function(corner) {
      north = corner.latitude > north ? corner.latitude : north;
      south = corner.latitude < south ? corner.latitude : south;
      west = corner.longitude > west ? corner.longitude : west;
      east = corner.longitude < east ? corner.longitude : east;
    });
  });
  
  // 111,111 meters = 1 degree latitude
  heightInPatches = Math.ceil(111111 * (north - south) / 100);
  degreesPerHundredMeterLat = 100/111111;
  halfHeight = degreesPerHundredMeterLat / 2;

  // 111,111 * cos(latitude) = 1 degree longitude
  widthInPatches = Math.ceil(111111 * Math.cos(farm.location.latitude * (Math.PI/180)) * (west - east) / 100);
  degreesPerHundredMeterLng = 100/(111111 * Math.cos(farm.location.latitude * (Math.PI/180)));
  halfWidth = degreesPerHundredMeterLng / 2;

  simulation.width = widthInPatches;
  simulation.height = heightInPatches;

  // Convert field bounds into pixel coordinates
  simulation.fields = farm.field_bounds.map( function(boundary) {
    return boundary.map( function(corner) {
      return {
        x: (corner.longitude - east) * (simulation.width / (west - east)),
        y: (corner.latitude - south) * (simulation.height / (north - south))
      };
    });
  });


  postMessage({type: 'size_update', size: {width: simulation.width, height: simulation.height, fields: simulation.fields}});
  
<% for property in Soil::PROPERTIES %>
  simulation.soil.<%= property %> = new Uint8Array(widthInPatches * heightInPatches );
  postMessage({type: '<%= property %>_update', <%= property %>: simulation.soil.<%= property %>});
<% end %>

}

//=====================================================
// Simulation update methods


// Update the simulation
//-----------------------------------------------------
function update(simulation) {
  updateWeather();
  updateSoil();
  // updateCrops();
}

// Update the weather
//-----------------------------------------------------
function updateWeather() {

  <%= Weather.find(data["weather"]["id"]).code.html_safe %>

  postMessage({
    type: 'weather_update',
    weather: simulation.weather
  });
}

// Update the soil
//-----------------------------------------------------
function updateSoil() {
  for(x = 0; x < simulation.width; x++) {
    for(y = 0; y < simulation.height; y++) {
      index = x + simulation.width * y
      <%= Soil.find(data["soil"]["id"]).code.html_safe %>
    }
  }
<% for property in Soil::PROPERTIES %>
  postMessage({type: '<%= property %>_update', <%= property %>: simulation.soil.<%= property %>});
<% end %>
}

